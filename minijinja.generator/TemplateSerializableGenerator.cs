using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniJinja.SourceGenerator;

[Generator]
public class TemplateSerializableGenerator : IIncrementalGenerator {
  public void Initialize(IncrementalGeneratorInitializationContext context) {
    // Register a marker attribute that users can apply to their classes
    context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
      "GenerateTemplateSerializableAttribute.g.cs",
      """
      namespace MiniJinja {
        /// <summary>
        /// Marks a type to have its ITemplateSerializable.ToTemplateValues() method generated automatically.
        /// </summary>
        [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
        public sealed class GenerateTemplateSerializableAttribute : System.Attribute {
        }
      }
      """));

    // Find all types marked with [GenerateTemplateSerializable]
    var classDeclarations = context.SyntaxProvider
      .CreateSyntaxProvider(
        predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
        transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
      .Where(static m => m.HasValue);

    context.RegisterSourceOutput(classDeclarations, static (spc, typeInfo) => Execute(typeInfo.Value, spc));
  }

  private static bool IsSyntaxTargetForGeneration(SyntaxNode node) {
    return node is TypeDeclarationSyntax typeDeclaration &&
           typeDeclaration.AttributeLists.Count > 0;
  }

  private static (INamedTypeSymbol Symbol, TypeDeclarationSyntax Syntax)? GetSemanticTargetForGeneration(GeneratorSyntaxContext context) {
    var typeDeclaration = (TypeDeclarationSyntax)context.Node;

    foreach (var attributeList in typeDeclaration.AttributeLists) {
      foreach (var attribute in attributeList.Attributes) {
        var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
        if (symbol is not IMethodSymbol attributeSymbol) {
          continue;
        }

        var attributeType = attributeSymbol.ContainingType;
        var fullName = attributeType.ToDisplayString();

        if (fullName == "MiniJinja.GenerateTemplateSerializableAttribute") {
          var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
          if (typeSymbol is not null) {
            return (typeSymbol, typeDeclaration);
          }
        }
      }
    }

    return null;
  }

  private static void Execute((INamedTypeSymbol Symbol, TypeDeclarationSyntax Syntax) typeInfo, SourceProductionContext context) {
    var typeSymbol = typeInfo.Symbol;

    // Get all public properties
    var properties = typeSymbol.GetMembers()
      .OfType<IPropertySymbol>()
      .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                  p.GetMethod is not null &&
                  !p.IsStatic)
      .ToList();

    if (properties.Count == 0) {
      return;
    }

    var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
      ? null
      : typeSymbol.ContainingNamespace.ToDisplayString();

    var typeName = typeSymbol.Name;
    var typeKind = typeInfo.Syntax.Keyword.Text; // "class" or "struct"

    var source = GenerateSource(namespaceName, typeName, typeKind, properties);
    context.AddSource($"{typeName}.g.cs", source);
  }

  private static string GenerateSource(
    string? namespaceName,
    string typeName,
    string typeKind,
    List<IPropertySymbol> properties) {

    var sb = new StringBuilder();
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();

    if (namespaceName is not null) {
      sb.AppendLine($"namespace {namespaceName};");
      sb.AppendLine();
    }

    sb.AppendLine($"partial {typeKind} {typeName} : MiniJinja.ITemplateSerializable {{");
    sb.AppendLine("  public System.Collections.Generic.Dictionary<string, MiniJinja.Value> ToTemplateValues() {");
    sb.AppendLine("    return new System.Collections.Generic.Dictionary<string, MiniJinja.Value> {");

    foreach (var property in properties) {
      var propertyName = property.Name;
      var camelCaseName = char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);

      sb.Append($"      [\"{camelCaseName}\"] = ");

      // Determine the appropriate Value.From* method based on the property type
      var typeInfo = property.Type;
      var conversionMethod = GetConversionMethod(typeInfo);

      sb.AppendLine($"{conversionMethod}({propertyName}),");
    }

    sb.AppendLine("    };");
    sb.AppendLine("  }");
    sb.AppendLine("}");

    return sb.ToString();
  }

  private static string GetConversionMethod(ITypeSymbol typeSymbol) {
    var typeName = typeSymbol.ToDisplayString();

    return typeName switch {
      "string" => "MiniJinja.Value.FromString",
      "bool" => "MiniJinja.Value.FromBool",
      "int" => "MiniJinja.Value.FromInt",
      "long" => "MiniJinja.Value.FromInt",
      "float" => "MiniJinja.Value.FromDouble",
      "double" => "MiniJinja.Value.FromDouble",
      "string?" => "MiniJinja.Value.FromString",
      _ when typeSymbol.IsValueType => "MiniJinja.Value.FromAny",
      _ => "MiniJinja.Value.FromAny"
    };
  }
}
